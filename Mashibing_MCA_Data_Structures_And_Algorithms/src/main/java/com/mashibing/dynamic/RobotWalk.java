package com.mashibing.dynamic;

/**
 * 动态规划题目一：
 * 假设有排成一行的N个位置，记为1~N，N 一定大于或等于 2
 * 开始时机器人在其中的M位置上(M 一定是 1~N 中的一个)
 * 如果机器人来到1位置，那么下一步只能往右来到2位置；
 * 如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；
 * 如果机器人来到中间位置，那么下一步可以往左走或者往右走；
 * 规定机器人必须走 K 步，最终能来到P位置(P也是1~N中的一个)的方法有多少种
 * 给定四个参数 N、M、K、P，返回方法数。
 *
 * 动态规划：
 * 1、首先动态规划必须得是基于递归，没有递归就谈不上动态规划
 * 2、在递归的过程中如果有重复的计算，那么就使用缓存，第一次计算的时候将结果放入缓存中，如果递归的过程遇到重复计算了就直接从缓存里面取。
 * 如果递归的过程中没有重复计算的情况，那就没有必要使用动态规划。
 *
 * 动态规划通用步骤：
 * 三个大步骤：
 * 1、版本一：写出一个暴力递归版本来实现题目
 * 2、版本二：在版本一的基础上改出使用缓存的版本来避免重复计算，这个是版本二
 * 3、版本三：在版本一的基础上改出使用二维矩阵的方式，这个就是最终版本
 * 所有动态规划的题都是要经过这三个版本的，都是先做出暴力递归（版本一），然后加入傻缓存（版本二），最后通过二维矩阵的分析做出最终版本（版本三），
 * 这三个过程最关键的就是第一步，即必须想出暴力递归的版本，然后找出递归的重复逻辑，版本二就出来了，至于版本三属于"提高版"，能分析出来最好。
 *
 * 具体步骤：
 * 1、你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用
 * 2、找到那些参数的变化会影响返回值，对每一个列出变化范围
 * 3、参数间的所有的组合数量，意味着表大小
 * 4、记忆化搜索的方法就是傻缓存，非常容易得到
 * 5、规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解
 * 6、对于有枚举行为的决策过程，进一步优化
 * （经过跟老师沟通了解到：如果是为了面试的话，对于动态规划的题，版本二就已经可以应对大部分面试了，不会因为你优化不出第三个版本而卡你，除非面试官明确要求让你搞出第三个版本，否则版本二就可以应付大部分面试）
 *
 * 本题思路：
 * 见下面的注释
 *
 * 课程：体系班课时167-172
 */
public class RobotWalk {
    // ---------------版本一：暴力递归版---------------
    /**
     *
     * @param N 一共有多少个位置排成一排
     * @param start 机器人开始的位置，相当于题目中的M
     * @param target 机器人要去的地方，相当于题目中的P
     * @param K 机器人到达目的地必须要走的步数
     * @return
     */
    public static int robotWalk1(int N, int start, int target, int K) {
        /*
        按理说每个参数都要校验有效性，但是题目已经对其他参数做了限制描述，比如"M 一定是 1~N 中的一个"、"P也是1~N中的一个"等，
        那么代码就不需要做校验了，就认为这些参数传进来的一定是按照题目要求的。
         */
        if(K < 1) {
            return -1;// 或者抛一个异常也行
        }
        return recurse1(start, target, K, N);
    }

    /**
     *
     * @param cur 机器人当前的位置
     * @param rest 机器人还需走多少步就到目的地了
     * @param target 机器人要去的目的地
     * @param N 一共有多少个位置排成一排
     * @return 返回的就是题目要求的方法数
     */
    private static int recurse1(int cur, int target, int rest, int N) {// 注意：当参数有很多时可以封装成一个类，如果不封装，而且参数相同类型的有很多时，主要不要传错，测试时就将target和rest传反了
        /*
         base case：当没有剩余步数的时候，看看当前位置是不是正好是目标点，如果是说明最后一步正好走到目标点上，
         说明这个方法符合题目要求，即找到了一个方法，返回1，否则就代表走到最后一步也没有找到方法，返回0
         */
        if(rest == 0) {
            return cur == target ? 1: 0;
        }

        // 能走到这里说明还有剩余步数可以走
        /*
        注意：题目说的是"假设有排成一行的N个位置，记为1~N"，人家没说是数组，且人家说了第一个位置是1，那么就不要把cur和target想像成数组下标，所以cur的范围从1开始。
        分三种情况：
        1、当前位置是最左边的
        根据题目描述，这N个位置不是首尾相接的，没有成环，所以当cur=1时，它的第一步必须是从1挪到2，没有别的选择。在这种情况下，它的目标是从1移动K步到达target，
        但是第一步必须是1->2，所以问题可以转化成从2移动K-1步到target
        2、当前位置是最右边的
        同理，它的第一步必须是从N挪到N-1，所以问题转化成从N-1挪动K-1步到大target
        3、当前位置在1-N中间的某个位置
        这种情况下，它第一步既可以向左走也可以向右走，即它有两个选择：第一个选择是向左走然后去探索所有能达到目的的方法，第二个选择是向右走然后去探索所有能达到目的的方法。
        由于题目要求的最终结果是所有方法的总个数，那么这种情况下将两个方法各自探索的方法数加一起返回就可以了。
         */
        int total = 0;
        if(cur == 1) {
            total = recurse1(2, target, rest - 1, N);// 之所以第二个参数传入rest - 1是因为从1到2已经消耗掉了1步
        } else if(cur == N) {
            total = recurse1(N - 1, target, rest - 1, N);// 和上面同理
        } else {// 当前位置在1-N中间的某个位置
            total = recurse1(cur - 1, target, rest - 1, N) + recurse1(cur + 1, target, rest - 1, N);
        }

        return total;
    }
    // -------------------------------------------
    // ---------------版本二：傻缓存版---------------
    /*
    思路：
    通过分析recurse1可以发现，recurse1的入参中target和N这两个参数在每次递归调用中都没有发生过变换，把最初用户传进来的这两个值一路传递下去，
    所以可以得出结论：这两个参数不会对递归产生影响，能够产生影响的是另外两个参数cur和rest。
    拿一个普适位置（非所有两端的位置）来分析：
    假设：有N=20个位置，start=10，target=15，K=8，即从第10个位置开始走，走8步走到第15个位置。由于N和target不影响递归的过程，所以只看(cur,rest)就可以了。
    1、要想知道(10,8)就必须知道(9,7)和(11,7)
    2、要想知道(9,7)就必须知道(8,6)和(10,6)
    3、要想知道(11,7)就必须知道(10,6)和(12,6)
    这里就需要用到缓存了，第三步要计算(10,6)的情况，但是(10,6)已经在第2步算过了，如果再算一遍就是重复计算了，不如在第2步第一次算的时候将(10,6)放入缓存，
    以后用到(10,6)的计算结果时直接从缓存里面取，这就是动态规划的精髓。
    可以用一个二维数组来做缓存，第一维（横坐标）是cur，第二维（纵坐标）是rest，那这个数组申请多大长度呢？
    这里就要注意了：横坐标要放下N个位置，而题目说的位置是从1开始的，为了能放下这1-N个位置而且还要让这1-N做下标，所以横坐标要申请N+1个长度，索引范围是[0,N-1],
    其中第0个位置用不到，因为第一个位置是从1开始。纵坐标最小是0最大是K所以要申请K+1个长度，所以缓存是：int[N+1][k+1]
     */

    public static int robotWalk2(int N, int start, int target, int K) {
        if(K < 1) {
            return -1;
        }
        int[][] buf = new int[N + 1][K + 1];

        // 初始化缓存，将所有元素都置为-1，-1代表该位置上没有保存过东西，否则代表该位置上保存过东西
        for(int i = 0; i < N + 1; i++) {
            for(int j = 0; j < K + 1; j++) {
                buf[i][j] = -1;
            }
        }

        return recurse2(start, target, K, N, buf);
    }

    private static int recurse2(int cur, int target, int rest, int N, int[][] buf) {
        // 先看看缓存有没有，如果有直接返回
        if(buf[cur][rest] != -1) {
            return buf[cur][rest];
        }

        if(rest == 0) {
            int result = cur == target ? 1: 0;
            buf[cur][rest] = result;// 返回前加入缓存
            return result;
        }

        int total = 0;
        if(cur == 1) {
            total = recurse1(2, target, rest - 1, N);// 之所以第二个参数传入rest - 1是因为从1到2已经消耗掉了1步
        } else if(cur == N) {
            total = recurse1(N - 1, target, rest - 1, N);// 和上面同理
        } else {// 当前位置在1-N中间的某个位置
            total = recurse1(cur - 1, target, rest - 1, N) + recurse1(cur + 1, target, rest - 1, N);
        }

        buf[cur][rest] = total;// 返回前加入缓存
        return total;
    }
    // -------------------------------------------
    // ---------------版本三：进阶版---------------
    /*
    思路：
    通过上面的第二版——用一个二维数组来做缓存，版本三就是将这个二维矩阵缓存在草稿纸上画出来（横坐标是cur，纵坐标是rest ），看看每一个格子里面的值应该怎么填，有什么规律。
    将二维矩阵展开之后，接下来就是要将每一个格子填上数字，分5个步骤：
    1、首先由于位置是从1开始的，所以横坐标是0的位置全部用不到，可以在图中用叉标记
    2、找递归的base case：if(rest == 0) {return cur == target ? 1: 0;}
    意思是当rest=0的时候（纵坐标为0的），只有cur=target的时候是1，其它都是0，所以[target][0]这个格子填1，其它是0
    3、找到最终题目要输出的是哪个格子的值。去找主函数是怎么调的：主函数要的是[start][K]的值，所以将[start][K]的值返回即可
    4、怎么得到最终要的[start][K]呢？就是将矩阵中的所有格子都填满，怎么填呢？看递归代码最普适的过程，即当cur既不等于1，也不等于N的时候，看看这个时候会依赖什么。
    从代码中可以看到：recurse1(cur - 1, rest - 1, target, N) + recurse1(cur + 1, rest - 1, target, N);
    普适的位置依赖于(cur - 1, rest - 1)和(cur + 1, rest - 1)，所以在二维矩阵中一个普适的格子依赖于它左下和右下两个格子，取这两个值的和，所以知道知道任意一个格子的左下和右下的值即可。
    特殊位置可以看做是普适位置的特例，比如当cur=1时，cur=1的所有列没有左下只有右下，那么就有什么算什么，就让当前位置等于它的右下就可以了；
    同理当cur=N时，cur=N的所有列没有右下只有左下。
    5、经过以上4个步骤所有各自都填满了，这一步就是回忆一下你填格子的顺序。首先，必须要在草稿纸上填满所有格子，然后看一下刚才填入的顺序：是固定某一个去填满这一行上的所有列，
    还是反过来：先固定某一列然后填满这一列的所有行，然后再看看是从左往右填的还是从右往左填的，同理看看"上->下"还是"下->上"，这取决于写代码的时候是先遍历列再遍历行，还是反过来，是正序遍历还是倒叙遍历。
    这样，整个格子就填满了，返回[start][K]的值即可。
     */

    public static int robotWalk3(int N, int start, int target, int K) {
        if(K < 1) {
            return -1;
        }
        int[][] buf = new int[N + 1][K + 1];// 仍然需要一个(N + 1)*(K + 1)大小的二维数组，但不需要将所有元素都初始化为-1，默认都是0
        // 1、填入base case格子的值：只有rest=0，cur=target那个格子的值是1，其它都是0，由于默认值就是0，所以只填入哪一个格子即可
        buf[target][0] =1;
        // 给格子填值
        // 注意：按照上面思路的第五步，可以看出应该先遍历列再遍历行，本题中列是rest，行是cur
        for(int rest = 1; rest < K + 1; rest++)  {
            for(int cur = 1; cur < N + 1; cur++) {
                if(cur == 1) {
                    buf[1][rest] = buf[2][rest - 1];
                } else if(cur == N) {
                    buf[N][rest] = buf[N - 1][rest - 1];
                } else {
                    buf[cur][rest] = buf[cur - 1][rest - 1] + buf[cur + 1][rest - 1];
                }
            }
        }

        return buf[start][K];
    }
    // -------------------------------------------

    public static void main(String[] args) {
        /*
        1 2 3 4 5
        N = 5
        target = 4
        K = 3
        start = 1
         */
        int N = 5;
        int target = 4;
        int K = 3;
        int start = 3;
        int walk1 = robotWalk1(N, start, target, K);
        System.out.println("walk1 = " + walk1);
        int walk2 = robotWalk2(N, start, target, K);
        System.out.println("walk2 = " + walk2);
        int walk3 = robotWalk3(N, start, target, K);
        System.out.println("walk3 = " + walk3);
    }
}
