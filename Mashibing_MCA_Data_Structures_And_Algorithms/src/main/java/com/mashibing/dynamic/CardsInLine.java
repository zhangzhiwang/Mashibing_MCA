package com.mashibing.dynamic;

/**
 * 动态规划题目2：
 * 给定一个整型数组arr，代表数值（非负）不同的纸牌排成一条线
 * 玩家A和玩家B依次拿走一张纸牌
 * 规定玩家A先拿，玩家B后拿
 * 但是每个玩家每次只能拿走最左或最右的纸牌
 * 玩家A和玩家B都绝顶聪明
 * 请返回最后获胜者的分数（牌面上的值就是分数值）。
 *
 * 思路：
 * 1、准备两个递归函数，一个是先手递归函数，一个是后手递归函数。
 * 2、先手递归函数：
 * （1）base case：只剩一张牌的时候，由于是先手所以他肯定有牌拿且只能那这一张牌。
 * （2）剩余牌数不只有一张：先手拿了一张牌之后，后手从剩余的排里面拿一张。由于两个玩家都"都绝顶聪明"，所以从先手的角度来看，他有两个选择：一个是拿最左边的牌，
 * 一个是拿最右边的牌，到底拿哪一个呢？如果他真的"绝顶聪明"，他选牌的策略一定要考虑以下两个因素：首先我选的牌一定是对我最有利的，我选完牌之后留下的局面一定是对对手最不利的。
 * 面对选择最左和最右两张牌时，先手也不知道选哪个，分为两种情况：先手选择最左的牌然后让后手选（调用后手递归函数）；先手选择最右的牌然后让后手选，这两种情况取最大值。
 * 3、后手递归函数：
 *（1）base case：只剩一张牌的时候，由于是后手所以他没有牌可拿，因为只剩一张牌的时候先手先拿一张，所以后手就没有牌可拿了。
 *（2）剩余牌数不只有一张。除了第一次先手是绝对的先手，从第二次以后先手后手就是一个先对的概念了，对于上一轮来说是后手，对于下一轮来说后手又变为了先手。
 * 由于后手也是"绝顶聪明"，所以他也希望自己拿到最好的留给对手的局面是最不好的，所以后手的递归要调用先手的递归。后手同样面对两个选择——选左还是选右，
 * 但是对于第一次来说，先手是绝对的先手，他第一次选完牌之后留给后手的就是最不利的局面，他让后手在最不利的局面里面去做选择，所以后手选左还是选右的两种情况要取最小值。
 * 4、主函数
 * 通过上面两个递归函数分别得到了先手的最大收益和后手的最大收益，主函数取这两个最大收益的最大值，即题目要求的最后获胜者分数。
 *
 * 课程：体系班课时163-180
 */
public class CardsInLine {
    // ---------------版本一：暴力递归版---------------
    public static int cardsInLine1(int[] arr) {
        if(arr == null || arr.length == 0) {
            throw new RuntimeException("参数有误！");
        }

        int N = arr.length;
        // 获取先手的最大收益
        int p1 = f1(arr, 0, N - 1);
        // 获取后手的最大收益
        int p2 = g1(arr, 0, N - 1);

        return Math.max(p1, p2);
    }

    /**
     * 先手递归函数
     * @param arr
     * @param L 数组左边界索引
     * @param R 数组右边界索引
     * @return
     */
    private static int f1(int[] arr, int L, int R) {
        // base case：就剩一张牌
        if(L == R) {
            return arr[L];// 由于是先手所以他有牌可拿且只能拿这一张牌
        }
        
        // 能走到这里说明剩余的不止一张牌，先手面临的选择有两个：拿左还是拿右
        // 如果先手拿了左，后手可以选的范围就是[L+1,R]，然后调用后手的递归函数
        int p1 = arr[L] + g1(arr, L + 1, R);
        // 同理，如果先手拿了右，后手可以选的范围就是[L,R-1]，然后调用后手的递归函数
        int p2 = arr[R] + g1(arr, L, R - 1);
        
        // 以上两种情况只能发生一个，由于先手想赢，所以肯定是取两种情况收益的最大值
        return Math.max(p1, p2);
    }

    /**
     * 后手递归函数
     * @param arr
     * @param L
     * @param R
     * @return
     */
    private static int g1(int[] arr, int L, int R) {
        // base case：当只剩一张牌的时候，由于是后手，所以那张牌肯定先被先手拿了，自己就没的拿了
        if(L == R) {
            return 0;
        }
        
        /*
         情况1：先手已经选走了L，留给后手选择范围是[L+1,R]，但是后手也想赢，也绝顶聪明，所以他要在先手留给他最不好的局面里面做最大的努力，
         同时轮到后手选择的时候，后手又变成了下一轮的先手，他会和对手使用相同的策略——选择一个对自己最有利的，留给对手最不利的，
         所以，这里直接调用先手的函数即可，千万不要再加上arr[L]了。
         */
        int p1 = f1(arr, L + 1, R);
        // 道理同上，注意不能是arr[R]+f1(arr, L, R - 1)
        int p2 = f1(arr, L, R - 1);
        
        // 由于在第一次玩儿的时候是先手先选择的，所以它留给后手的局面一定是最不利的，所以这两种情况要取最小值
        return Math.min(p1, p2);
    }
    // -------------------------------------------
    // ---------------版本二：傻缓存版---------------
    /*
    思路：
    分析版本一的整个递归过程，看看递归函数的哪些参数会对递归过程产生影响，发现arr是始终不变的，从头一直传到尾，只有L和R是变的，所以只有(L,R)对整个递归产生影响。
    分析一下整个递归过程有没有重复计算，经过树形分析发现有重复过程，OK，可以用动态规划了。建立一张N*N的二维表int[N][N]，将结果缓存进去。
     */
    public static int cardsInLine2(int[] arr) {
        if(arr == null || arr.length == 0) {
            throw new RuntimeException("参数有误！");
        }

        /*
         准备两个大小为N*N的二维数组作为缓存并将值初始化为无意义的-1。
         为什么有的数组元素要初始化成负数，有的是默认的0就行？看题目要求，本题的题目说牌面大小是非负数，说明0是有意义的值，
         如果0对于题目来说是无意义的，那么就无须可以初始化，用默认的0就行
         */
        int N = arr.length;
        int[][] bufF = new int[N][N];// 先手用的缓存
        int[][] bufG = new int[N][N];// 后手用的缓存
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                bufF[i][j] = -1;
                bufG[i][j] = -1;
            }
        }

        // 获取先手的最大收益
        int p1 = f2(arr, 0, arr.length - 1, bufF);
        // 获取后手的最大收益
        int p2 = g2(arr, 0, arr.length - 1, bufG);

        return Math.max(p1, p2);
    }
    // -------------------------------------------
    /**
     * 由于缓存整全局缓存，每一步递归都要把结果缓存进去，所以肯定是要在递归函数的入参增加一个缓存，这个缓存最初是由主函数传进去的
     * @param arr
     * @param L
     * @param R
     * @param buf
     * @return
     */
    private static int f2(int[] arr, int L, int R, int[][] buf) {
        if(buf[L][R] != -1) {// 缓存有直接取
            return buf[L][R];
        }

        // base case：就剩一张牌
        if(L == R) {
            buf[L][R] = arr[L];
            return arr[L];// 由于是先手所以他有牌可拿且只能那这一张牌
        }

        // 能走到这里说明剩余的不止一张牌，先手面临的选择有两个：拿左还是拿右
        // 如果先手拿了左，后手可以选的范围就是[L+1,R]，然后调用后手的递归函数
        int p1 = arr[L] + g1(arr, L + 1, R);
        // 同理，如果先手拿了右，后手可以选的范围就是[L,R-1]，然后调用后手的递归函数
        int p2 = arr[R] + g1(arr, L, R - 1);

        // 以上两种情况只能发生一个，由于先手想赢，所以肯定是取两种情况收益的最大值
        int max = Math.max(p1, p2);
        buf[L][R] = max;
        return max;
    }

    private static int g2(int[] arr, int L, int R, int[][] buf) {
        if(buf[L][R] != -1) {
            return buf[L][R];
        }

        if(L == R) {
            buf[L][R] = 0;
            return 0;
        }

        int p1 = f1(arr, L + 1, R);
        int p2 = f1(arr, L, R - 1);

        int min = Math.min(p1, p2);
        buf[L][R] = min;
        return min;
    }
    // -------------------------------------------
    // ---------------版本三：最终版---------------
    /*
    思路：
    把先手和后手的两个二维矩阵展开，然后：
    1、看base case
    （1）先手的base case是当L=R时取arr[L]的值，而L=R就是二维表的对角线，对角线上的值就是原始数组从左到右的值。
    （2）后手的base case是当L=R时取0，所以后手对角线上的值都是0
    2、看题目要的最终结果在哪个格子上
    这个要去主函数看，看看主函数调递归函数传入的什么入参，就是主函数想要的。主函数调用先后手的递归函数传入的都是[0,N-1]，所以在两个矩阵上(0,N-1)就是主函数想要的。
    3、填格子
    下面要做的就是怎么把二维矩阵的格子都填满。怎么填？分析普适位置是怎么依赖的。怎么分析？看你递归代码是怎么写的。
    在代码中，f(L,R)要依赖g(L+1,R)和g(L,R-1)，g(L,R)要依赖f(L+1,R)和f(L,R-1)，所以可以得出结论：在先手二维矩阵中的任意一个格子x，它依赖于后手矩阵中相同位置格子（_x）的右边和下边，
    算出后手_x的右和下就得到了先手x位置的值，后手普适位置同理。依赖位置找好了，就看看怎么加工依赖位置的值，还是看代码，在代码中先手取的是依赖位置的最大值，后手取的是最小值。
    但是这里可以减轻一半的工作量，因为最少也就是有一张牌，即L=R，不可能出现L>R的情况，所以两个矩阵的右下部分全部画叉，只填左上即可。
    4、看顺序
    看自己在草稿纸上填格子的上下左右顺序。本题的填入顺序是斜着往右上填的，所以遍历的时候就要斜着往右上遍历，代码最难地方的也就是怎么斜着往右上遍历
     */
    public static int cardsInLine3(int[] arr) {
        if(arr == null || arr.length == 0) {
            throw new RuntimeException("参数有误！");
        }

        int N = arr.length;
        int[][] bufF = new int[N][N];
        int[][] bufG = new int[N][N];
        // 先填入对角线的值
        for(int i = 0; i < N; i++) {// 填入先手对角线的值
            bufF[i][i] = arr[i];
        }
        // 后手对角线都是0，由于默认值就是0，所以默认已经填好了

        // 斜着往右上遍历填值
        // L是行，R是列，外循环先遍历列
        for(int R = 1; R < N; R++) {// 分析一下二维表的特点：两个二维表对角线已经填好了，右下部分不用填，可以看出列实际上是从1开始往后走的
            int _R = R;// 注意：由于内存循环需要列++，外层循环也要列++，两个列++是控制不同的东西的，不能串了，所以拷贝一个_R出来，内层循环使用_R，这样外层循环不受干扰
            int L = 0;// 外循环每遍历到一个新列上行都是从0开始填的
            while(_R < N) { // 如果是斜着往右上走，那么肯定是列先越界，所以判断列不越界就可以了，列最多能达到N-1的位置
                // 填格子
                bufF[L][_R] = Math.max(arr[L] + bufG[L + 1][_R], arr[_R] + bufG[L][_R - 1]);
                bufG[L][_R] = Math.min(bufF[L + 1][_R], bufF[L][_R - 1]);

                // 一个格子填完之后下一个格子就是它的右上方，右上的表示方法就是行++、列++
                L++;
                _R++;
            }
        }

        // 返回两个目标格子的最大值
        return Math.max(bufF[0][N - 1], bufG[0][N - 1]);
    }
    // -------------------------------------------

    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6};
//        int[] arr = { 5, 7, 4, 5, 8, 1, 6, 0, 3, 4, 6, 1, 7 };
        int result1 = cardsInLine1(arr);
        System.out.println("result1 = " + result1);
        int result2 = cardsInLine2(arr);
        System.out.println("result2 = " + result2);
        int result3 = cardsInLine3(arr);
        System.out.println("result3 = " + result3);
    }
}
