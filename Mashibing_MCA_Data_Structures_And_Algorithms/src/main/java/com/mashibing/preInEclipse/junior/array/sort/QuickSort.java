package com.mashibing.preInEclipse.junior.array.sort;

/**
 * 快速排序
 * 思路：
 * 以数组的最后一个元素为标准值，让数组所有小于这个标准值的放到数组的左边组成小于区，让数组所有等于这个标准值的放到数组的中间组成等于区，
 * 让数组所有大于这个标准值的放到数组的右边组成大于区，其中小于区和大于区可以无序，而等于区是天生排好序的。如何让小于区和大于区也有序呢？
 * 将小于区和大于区看做子数组递归上面的过程。如何将数组划分成小于区、等于区和大于区呢？
 * 1、让小于区的初始范围在数组左边界的左边，即小于区初始的时候不包含任何元素
 * 2、设置指针i为当前位置，i的初始位置位于数组的左边界
 * 3、让大于区的初始位置在数组的右边界位置上，即大于区初始的时候包含一个元素，就是数组的最后一个元素
 * 4、数组的右边界是标准值，所有值都要和标准值比较
 * 5、规则：
 * （1）当前位置i的值小于标准值：i位置和小于区右边界的下一个位置互换，小于区右边界向右扩一个位置，i向后移动一个位置
 * （2）当前位置i的值等于标准值：小于区和大于区都不动，只有i向后移动一个位置即可
 * （3）当前位置i的值大于标准值：i位置和大于区左边界的前一个位置互换，大于区左边界向左扩一个位置，i不动
 * （4）整个循环的条件是i小于大于区左边界的位置，当i和大于区左边界的位置相遇时（即等于时）循环结束
 * 6、最后一步是将数组右边界的值和大于区左边界的值交换，如果使用递归，那么每次递归要返回等于区的左边界和右边界的索引值
 * 7、如果使用递归，那么将上面的步骤递归下去
 *
 * 时间复杂度：
 * 经典快排的时间复杂度是O(N^2)，但是在经典快排的实现中命名使用了递归为什么复杂度是O(N^2)呢？因为在快排的递归中，每次左右两部分的递归规模可能是不一样的，
 * 不能用Master公式来计算时间复杂度，因为Master公式的使用前提是递归的过程数据规模必须是一致的，都是N/b规模。
 * 经典快排的时间复杂度O(N^2)是按照最坏的情况计算的，最坏的情况就是原数组已经是排好序的了，每次递归都是以范围内最右边的数作为基准数，所以每次操作后根本就没有右组，
 * 即在process方法里的右组递归（第二次递归）根本用不到，每次递归都要考查范围内的所有数据，所以时间复杂度是O(N^2)。
 * 如果引入随机机制，可以让快排的时间复杂度收敛到O(N*logN)，原因见com.mashibing.array.sort.QuickSort3的注释，课程见：体系班课时44。
 * 空间复杂度：
 * 经典快排的额外空间复杂度是O(N)，因为经典快排是按照最坏的情况估算的，即原数组已经排好序了。由于每次递归都要保存等于区的左边界和右边界从而确定下次递归的左组和右组的范围，
 * 但是在最坏的情况下，每次等于区的左边界都是范围内的最后一个数，而数组的每一个元素都可作为某一次递归等于区的左边界（因为原数组就已经排好序了），所以申请保存左边界的变量
 * 不是和数据量无关的，而是和数据量有关的，所以额外空间复杂度是O(N)而不是O(1)。
 * 但是引入随机机制，最好的情况是左边界落在了中间的位置（右边界同理），那么每次递归只记录范围内中间的位置即可，所以额外空间复杂度是O(logN)，同理右边界也是O(logN)，
 * 忽略常数项就是O(logN)。但是最好的情况出现的概率是1/N，通过计算数学期望并经过数学推导最终的额外空间复杂度收敛于O(logN)。
 *
 * @author zhangzhiwang
 * @date 2022年2月10日 下午2:30:18
 */
public class QuickSort {
	public static void main(String[] args) {
		int[] arr = { 1, 7, 4, 4, 5, 6, 0, 2, 9, 8, 4 };
//		int[] arr = { 7, 9, 8, 4 };
		quickSort(arr);
		for (int i : arr) {
			System.out.print(i + "\t");
		}
	}

	private static void quickSort(int[] arr) {
		// 校验
		if (arr == null || arr.length <= 1) {// 无需排序的情况
			return;
		}

		process(arr, 0, arr.length - 1);
	}

	/**
	 * 将数组的arr的[l,r]范围内排好序
	 * 
	 * @author zhangzhiwang
	 * @date 2022年2月10日 下午2:47:02
	 */
	private static void process(int[] arr, int l, int r) {
		// 跳出递归的条件
		/**
		 * l > r的时候发生在上一轮调整完之后子数组已经没有小于区了，即上一轮的调整后等于区的左边界就是子数组的左边界l，上一轮调用本轮的process时传入的r就是l-1，所以导致本轮l > r
		 * l = r的时候发生在上一轮调整后小于区的子数组就剩下两个元素了且已排好序，且第一个元素在小于区，再往下传到本轮的时候l和r传入的欧式第二个元素的索引，所以l=r。
		 */
		if (l >= r) {
			return;
		}

		// 每经过一次sort方法，都会将数组在[l,r]范围内分成三部分，其中相等区已天然排好序，后面要做的就是将小于区的子数组和后面的大于区的子数组进行排序，方式就是递归调用process方法
		int[] equalArea = sort(arr, l, r);
		// 将小于区的子数组排序
		process(arr, l, equalArea[0] - 1);// 小于区子数组的范围是l到相等区左边界的前一个位置
		// 将大于区的子数组排序
		process(arr, equalArea[1] + 1, r);// 大于区子数组的范围是到相等区右边界的后一个位置到r
		/*
		 注意：虽然上面代码的形式是让左边去递归然后让右边去递归，但是左右递归的数据归模可能是不一样的，不能用Master公式来计算时间复杂度，
		 因为Master公式的使用前提是递归的过程数据规模必须是一致的，都是N/b规模。
		 */
	}

	/**
	 * sort方法是将数组在[l,r]范围内分成三段：左边是小于区部分（无序），中间是等于区部分（天然有序），右边是大于区部分（无序）
	 * 
	 * @param arr 原始数组
	 * @param l 数组左边界
	 * @param r 数组右边界
	 * @return int[] 相等区的左右边界索引
	 * @author zhangzhiwang
	 * @date 2022年2月10日 下午4:29:57
	 */
	private static int[] sort(int[] arr, int l, int r) {
		int lessR = l - 1;// 小于区的右边界起始索引在l的左边，即小于区初始的时候没有元素
		int moreL = r;// 大于区的左边界起始索引在最后一个元素，即大于区初始的时候有一个元素，就是最后一个元素
		int num = arr[r];// 以数组的最后一个元素为比较的标准值
		int i = l;// i是当前指针，其实在数组的最左边

		while (i < moreL) {// 当当前指针i和大于区左边界moreL相遇的时候退出循环
			if (arr[i] < num) {// 情况1：当前值小于标准值的时候：1、当前值和小于区右边界的下一个位置互换 2、小于区右扩一个位置 3、当前位置右移一个位置
				exchange(arr, i, lessR + 1);
				i++;
				lessR++;
				// 装逼一点的写法是将以上三行代码合并为一行，但是不好理解：
				//				exchange(arr, i++, ++lessR);
			} else if (arr[i] > num) {
				/**
				 * 情况2：当前值大于标准值：1、当前值和大于区左边界的前一个位置互换 2、大于区左扩一个位置 3、当前位置不动
				 * 注意：这里和情况1不一样的是当前位置不动。为什么呢？因为在情况1中，当前位置已经和标准值比较过一次了，所以下一次肯定要比较别的元素了，所以要后移;
				 * 而情况二在交换完成后，原来在大于区左边界的前一个位置的元素和标准值还有比较过，所以不能移动当前指针
				 */
				exchange(arr, i, moreL - 1);
				moreL--;
				// 装逼一点的写法是将以上两行代码合并为一行，但是不好理解：
				// exchange(arr, i, --lessR);
			} else {// 情况3：当前位置的元素和标准值相等，当前位置右移一个位置即可
				i++;
			}
		}
		// 上面你的while循环退出来之后数组在[l,r]范围内已经被分为了三部分：小于区在左边，等于区在中间，大于区在右边，但是小于区和大于区内的元素并不是有序的

		// 最后一步：将大于区的头尾元素互换
		exchange(arr, moreL, r);

		// 返回相等区左右边界的索引
		return new int[] { lessR + 1, moreL };// 相等区的左边界是小于区右边界的下一个位置，相等区的右边界是大于区的第一个位置（注意不是大于区的前一个位置，因为上一步将大于区的头尾元素互换了，原来数组在r位置的元素就是标准值，标准值肯定是在等于区的）
	}

	/**
	 * 交换数组arr位置i和位置j上的元素
	 * 
	 * @param arr
	 * @param i 索引
	 * @param j 索引
	 * @author zhangzhiwang
	 * @date 2022年2月10日 下午4:12:11
	 */
	private static void exchange(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}
}
