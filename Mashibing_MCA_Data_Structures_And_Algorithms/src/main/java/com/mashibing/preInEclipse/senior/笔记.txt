一、时间复杂度
1、时间复杂度描述的是算法的执行时间随着数据量的增加的变化情况，所以时间复杂度关心的是和数据量有关的高阶项，低阶项和常数项可忽略，
原因是当数据量趋向无穷大的时候低阶项和常数项对运行时间的影响很小，可忽略不计。
2、算法步骤的拆分
评估算法时间复杂度的时候要将整个算法按照步骤进行拆分，每一步要细化到常数操作（O(1)）为止。比如：算法的其中一步是找到N个元素中找到最小值并和某一个数交换，这样分解还没有达到常数级操作，
应该将这一步继续拆分为三个步骤：第一是遍历N个元素，第二是将每一个值和某一个标准值作比较来判断它是否最小，第三是将最小值和某一个值交换。
第一步的时间复杂度是O(N)，第二步比较大小是O(1)，第三步将两个数交换是O(1)，由于时间复杂度不考虑低阶项和常数项所以这一大步的时间复杂度是O(N)。
3、如何评估一个算法的时间复杂度？
（1）将一个算法拆分为若干个步骤，每一步都要精确到O(1)的操作。
（2）写出所有步骤的O(1)操作与数据量N的数学表达式关系。
（3）化简数学表达式，找出数据量N的高阶项
实际上，如果将一个算法被差拆分为若干个最细粒度的O(1)操作，那么算法复杂度就是看看完成一个算法需要多少个O(1)操作，所以算法复杂度实质上是看O(1)操作和数据量N的关系。
4、常数操作O(1)
只要是某个操作和数据量无关，是固定时间就能完成的，那么它就是常数操作。常见的常数操作有：
（1）加减乘除
（2）位运算
（3）赋值、比较、自增、自减
（4）数组寻址
如果执行时间不固定和数据量有关，那么就是非常数操作，比如循环。
·有关HashMap的get方法的时间复杂度是O(1)的讨论：
如果HashMap的key是一个字符串，那么根据HashMap的get源码可知，它会计算key的hashcode，而key又是String类型的，最终会调用String的hashcode方法，查看String.hashcode()源码
可知，hashcode的计算过程是遍历字符串的所有字符来进行计算的，所以hashcode计算String类型的key的hashcode的时间复杂度和字符串的长短有关，如果从遍历字符串的角度来看这个时间复杂度是O(N)的。
如果字符串比较短，可以忽略这个O(N)，那么HashMap的get方法的时间复杂度才是O(1)。

5、时间复杂度为什么是大写的O来表示？
大写的O代表最坏情况。在数据量N一定的情况下，数据值分布的情况也会影响到时间复杂度的分析。
比如：在同样N=7的情况下，现在要插入排序，如果给定数组的数据值分布就是排好序的[1,2,3,4,5,6,7]，那么经过完插入排序之后发现时间复杂度是O(N)，因为元素不需要交换；
如果给定数组的数据值分布就是逆序排好序的[7，6，5，4，3，2，1]，那么经过完插入排序之后发现时间复杂度是O(N^2)，因为每一个元素都要和前面的所有元素交换。
所以时间复杂度用大写的O来表示是因为要用数据值分布最坏的情况来估算。
6、时间复杂度的常数项分析
在评估时间复杂度的时候是去掉常数项和低阶项的，如果评估出来两个算法的时间复杂度一样，那么这两个算法的运行时间就一样吗？
不一定，在不考虑空间复杂度的情况下，当初在评估两个算法时间复杂度的时候精确到了常数时间操作，但是常数时间和常数时间用时可能不一样，比如加减乘除是常数时间操作，位运算也是常数时间操作，但明显位运算要快。
到了比拼两个算法常数时间操作的时候就不需要理论分析了，直接大样本测试进行比较。
7、时间复杂度排名
有小到大（由好到坏）：
O(1) < O(logN) < O(N) < O(N*logN) < O(N^K)k为常数且大于1 < O(K^N)k为常数且大于1 < O(N!)
8、假如用for循环遍历一次数组的时间复杂度是O(N)，我调用了有限且已知的M次这样的for循环，时间复杂度仍然是O(N)。这里要说的是M必须是和数据量无关的，也就是无论N是多少M都是已知的次数，那么M就是常数项，
估算时间复杂度的时候可以省略，还是O(N)；如果M是和数据量有关的，那么时间复杂度就是O(M * N)。
还有，假如一个for循环套一个for循环，这两个for循环一个是与数据量N有关，另一个循环已知常数次，那么整体的时间复杂度还是O(N)，因为循环已知常数次的哪个for循环的时间复杂度是O(1)。
9、Master公式：
前提：Master公式是用来估算递归算法的时间复杂度的
（1）大问题拆分成若干个小问题，每个小问题的数据量规模都是一样的，也即是递归过程都是等规模的，都是大问题数据量的N/b。
（2）满足第一点，就可以根据这个公式来找出a、b、d的值，从而带入Master公式计算整个递归算法的时间复杂度
    T(N) = a * T(N / b) + O(N^d)，其中a、b、d为常数，N为整体数据量，N/b是递归的数据规模，O(N^d)是整个递归代码除了递归部分之外剩余代码的时间复杂度，
    a是等规模的递归过程发生了几次，也就是一次拆分将大问题拆分为几个等规模的小问题。（TODO 这样的话那是不是a永远等于b？）
（3）Master公式：
    1）若log(b,a) > d，则O(N^log(b,a))   （N的指数以大的为准）
    2）若log(b,a) < d，则O(N^d)
    3）若log(b,a) = d，则O(N^d*logN)
    其中log(b,a)是以b为底a的对数。
Master公式的三个要点：
（1）公式本身要记准
（2）结论的条件中log(b,a)是以b为底a为真数的，不要记反
（3）结论的结论中N的指数是以大的为准

二、空间复杂度
注意空间复杂度说的是额外空间复杂度，重点在”额外“二字。用户要求输入的不算额外空间，用户要求返回的不算额外空间，额外空间就是为了完成算法不得不开辟内存空间来完成功能。
它是描述额外开辟的内存空间和数据量N的关系。
对于”额外“的理解：
（1）比如用户给定一个数组，求这个数组的累加和。
算法的输入是用户给的数组，这个数组虽然占用内存空间，但是是用户给的已知条件，不是你为了完成算法而额外开辟的空间，所以输入的数组不能算做空间复杂度里面。
为了完成这个功能需要额外开辟一个变量，来保存所有元素的和，也就是我需要开辟已知的且有限的变量来完成功能，和数据量N无关，那么空间复杂度就是O(1)。
（2）比如用户给定一个数组，求这个数组出现频次最多的元素。
如果涉及一个map出来，key是元素值，value是频次，那么在最坏数据分布的情况下（原始数组所有元素都不一样），额外开辟的空间和数据量N事项等的，那么空间复杂度就是O(N)。
空间复杂度也是按最坏的情况估计。
（3）比如用户给定一个数组，让你生成一个新数组来拷贝这个数组的元素。
这时就需要开辟一个和原始数组长度一致的数组，然后进行拷贝，但是最终的空间复杂度是O(1)，原因是开辟出来的新数组虽然需要N个空间，但是这是题目要求的，题目要求的输入和输出都不是你为了完成功能而额外开辟的，
所以不能算在空间复杂度里面。

相比时间复杂度来说空间复杂度的的重要程度仅此之。

三、排序
1、排序算法：
（1）选择排序
（2）冒泡排序
（3）插入排序
（4）归并排序
（5）冒泡排序
（6）快速排序
（7）堆排序
（8）桶排序
	1）计数排序
		给定一个无序数组，每个元素的范围在[m,n]之间且m>=0且n不会太大，对该数组进行排序。
		思路：
		a）遍历一遍原数组arr，找出最大值maxValue
 		b）准备一个数组tmpArr，长度是maxValue + 1，这里的重点是tmpArr的索引值是arr的元素值，而tmpArr的元素值是arr某元素出现的次数
 		c）遍历tmpArr，根据每个元素出现的次数将所有元素平铺开来并逐个赋给arr
	2）基数排序
		给定一个无序数组，每个元素必须是非负的且能表达成十进制，对该数组进行排序。
		（其实负数也可以，要先找到最小的负数，然后所有元素都加上这个负数的相反数，将负数变为正数。但这里有一个隐患就是可能会超过数据类型的范围，一般情况下基数排序适用于非负数）
		思路：
		（有点难，暂略）
2、排序的算法的分类
（1）基于比较的排序
	排序算法的实现过程必须进行两两对比，这样的排序算法有：除了桶排序之外的排序算法。基于比较的排序算法的时间复杂度最好的是O(N*logN)。
	基于比较的排序适用范围是最广的，因为它没有什么特殊要求，只要是一个无序的数组就可以。
（2）不基于比较的排序
	不基于比较的排序，时间复杂度最好能达到O(N)，比如桶排序。“不基于比较的排序”的适用范围要比“基于比较的排序”窄，不基于比较的排序都是在一定的条件下，除了给定一个无序数组之外，要么元素有要求要么数组长度有要求或者其他要求，
	所以不基于比较的排序一般适用在某些具有特殊特征的数组。
3、排序算法的稳定性
	排完序之后，相同元素的相对位置没有改变，比如数组[1,2,3,2,1]排完序后是[1,1,2,2,3]，排序前原数组的第一个元素是1，假如标识为1_1，最后一个元素也是1，假如标识为1_2，
	所以在原始数组中1_1排在1_2之前，排完序后，新数组的第一个元素的1如果是1_1，而第二个元素的1如果是1_2，那么排完序之后1_1还是在1_2前面，相对位置没有变，这种排序算法就具有稳定性；
	相反如果排完序之后1_1跑到了1_2之后，就说这个排序算法不具有稳定性。
	当然对于基本数据类型来说具不具有稳定性没什么影响，如果数组的元素是复合类型那么就有可能有影响。比如元素是Student类的对象，Student类有两个属性：一个是年龄，一个是班级。
	如果先按照年龄排序得到一个新数组result1，再以result1为基础按照班级进行排序得到result2，如果排序算法是稳定的，那么在result2中，相同班级的学生年龄肯定是已经排好序的了；
	如果排序算法不是稳定的，那么相同班级的学生年龄的顺序不一定。
	那么哪些排序算法具有稳定性呢？
	具有稳定性的排序算法：冒泡排序、插入排序、归并排序
	不具有稳定性的排序算法：选择排序、快速排序、堆排序。这三个排序的时间复杂度都是O(N*logN)，但是最快的还是快速排序，因为快排的常数操作是最快的。
	在所有基于比较的排序中，快排是最快的，正如其名字一样。
4、各种排序算法的综合比较
见截图：各种排序算法比较.png
（1）基于比较的排序时间复杂度的极限是O(N*logN)，不基于比较的的排序时间复杂度的极限是O(N)
（2）想找到一个排序的时间复杂度是O(N*logN)，空间复杂度低于O(N)，还稳定的排序，目前理论界还不存在。
（3）在归并排序、随机快排和堆排序中，时间复杂度都是O(N*logN)，但是通过大样本测试，随机快排的常数操作是最快的，所以随机快排是这三个当中甚至是所有基于比较的排序当中
时间复杂度细小的，速度最快的，估计名称就是这么来的吧。
所以，在所有的基于比较的排序中到底用哪一个，得看需求是什么样的，因为没有一个绝对完美的排序。如果想要速度最快那么就选随机快排，如果想要占用最少的空间那就用堆排，如果想稳定，那就归并。
5、证明题：给出一棵二叉树head，并且给出了它的先序遍历结果和后序遍历结果，在这颗树中任意拿出一个节点x，x在先序和中序遍历中各自占据某个位置：
比如：先序遍历结果：______A_____x_____，后序遍历结果：___________x_____B________。
在先序、后序遍历结果中x的左边和右边都会有其它节点，现在假设在先序遍历的结果中x左边的所有节点组成一个集合A，在后序遍历的结果中x右边所有元素组成一个集合B，
请证明：集合A和集合B的交集里面有且只有x的祖先节点。

证明过程：
在一棵二叉树中随便找一个节点x，那么就可以把这颗二叉树里面的所有节点进行分类：x的所有祖先节点、x自己、x的所有左孩子、x的所有右孩子、x的所有左兄弟和x的所有右兄弟这6类。
证明这个问题要分两步：第一步证明x的所有祖先节点在A交B的结果集里面，第二步证明A交B的结果集里面只有x的所有祖先节点，不包含其它节点。
根据先序遍历的顺序——头左右，和后序遍历的顺序——左右头，以及节点的6个分类，可以推断出以下几个结论：
（1）x的所有祖先节点都在A交B里面
（2）x节点自己就不说了
（3）当x作为某棵子树的头结点时，在先序遍历的结果中：x的所有左孩子和右孩子都在x的右边；在后序遍历的结果中：x的所有左孩子和右孩子都在x的左边，所以A交B不包含x的左孩子和右孩子
（4）当x作为某棵树左子树的姿态时，在先序遍历的结果中：x的所有右兄弟都在x的右边；在后序遍历的结果中：x的所有右兄弟也都在x的右边，所以A交B不包含x的右兄弟
（5）当x作为某棵树右子树的姿态时，在先序遍历的结果中：x的所有左兄弟都在x的左边；在后序遍历的结果中：x的所有左兄弟也都在x的左边，所以A交B不包含x的左兄弟
所以，综上所述，A交B只包含x的所有祖先节点。
可以参考截图：证明A交B只包含x的所有祖先节点.jpeg
课程：体系班课时85-86



准备面试100题用到的笔记：
1、位运算
（1）与、或、非、异或的基本性质
    1）与：同1为1
    2）或：同0位0
    3）异或：异为1
    4）取反：1变0，0变1
（2）位运算的特性
    1）&：任何数与1与会还原该数本身，题目：打印一个int整数的二进制表示形式
    2）^：
        a）自己和自己异或永远等于0
        b）任何数与0异或会还原该数本身
        c）交换律：a ^ b ^ c = a ^ c ^ b
        题目：给定一个数组，这个数组里面有且只有一个数出现的次数是奇数次，其它所有元素出现的次数都是偶数次，找到这个出现奇数次的元素。（用到以上三点特性的）
    3)位运算能够还原某一位上的数本身的操作有：
        a）与1与
        b）与0异或