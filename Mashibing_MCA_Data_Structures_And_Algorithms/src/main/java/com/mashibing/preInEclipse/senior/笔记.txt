一、时间复杂度
1、时间复杂度描述的是算法的执行时间随着数据量的增加的变化情况，所以时间复杂度关心的是和数据量有关的高阶项，低阶项和常数项可忽略，
原因是当数据量趋向无穷大的时候低阶项和常数项对运行时间的影响很小，可忽略不计。
2、算法步骤的拆分
评估算法时间复杂度的时候要将整个算法按照步骤进行拆分，每一步要细化到常数操作（O(1)）为止。比如：算法的其中一步是找到N个元素中找到最小值并和某一个数交换，这样分解还没有达到常数级操作，
应该将这一步继续拆分为三个步骤：第一是遍历N个元素，第二是将每一个值和某一个标准值作比较来判断它是否最小，第三是将最小值和某一个值交换。
第一步的时间复杂度是O(N)，第二步比较大小是O(1)，第三步将两个数交换是O(1)，由于时间复杂度不考虑低阶项和常数项所以这一大步的时间复杂度是O(N)。
3、如何评估一个算法的时间复杂度？
（1）将一个算法拆分为若干个步骤，每一步都要精确到O(1)的操作。
（2）写出所有步骤的O(1)操作与数据量N的数学表达式关系。
（3）化简数学表达式，找出数据量N的高阶项
实际上，如果将一个算法被差拆分为若干个最细粒度的O(1)操作，那么算法复杂度就是看看完成一个算法需要多少个O(1)操作，所以算法复杂度实质上是看O(1)操作和数据量N的关系。
4、常数操作O(1)
只要是某个操作和数据量无关，是固定时间就能完成的，那么它就是常数操作。常见的常数操作有：
（1）加减乘除
（2）位运算
（3）赋值、比较、自增、自减
（4）数组寻址
如果执行时间不固定和数据量有关，那么就是非常数操作，比如循环。
·有关HashMap的get方法的时间复杂度是O(1)的讨论：
如果HashMap的key是一个字符串，那么根据HashMap的get源码可知，它会计算key的hashcode，而key又是String类型的，最终会调用String的hashcode方法，查看String.hashcode()源码
可知，hashcode的计算过程是遍历字符串的所有字符来进行计算的，所以hashcode计算String类型的key的hashcode的时间复杂度和字符串的长短有关，如果从遍历字符串的角度来看这个时间复杂度是O(N)的。
如果字符串比较短，可以忽略这个O(N)，那么HashMap的get方法的时间复杂度才是O(1)。

5、时间复杂度为什么是大写的O来表示？
大写的O代表最坏情况。在数据量N一定的情况下，数据值分布的情况也会影响到时间复杂度的分析。
比如：在同样N=7的情况下，现在要插入排序，如果给定数组的数据值分布就是排好序的[1,2,3,4,5,6,7]，那么经过完插入排序之后发现时间复杂度是O(N)，因为元素不需要交换；
如果给定数组的数据值分布就是逆序排好序的[7，6，5，4，3，2，1]，那么经过完插入排序之后发现时间复杂度是O(N^2)，因为每一个元素都要和前面的所有元素交换。
所以时间复杂度用大写的O来表示是因为要用数据值分布最坏的情况来估算。
6、时间复杂度的常数项分析
在评估时间复杂度的时候是去掉常数项和低阶项的，如果评估出来两个算法的时间复杂度一样，那么这两个算法的运行时间就一样吗？
不一定，在不考虑空间复杂度的情况下，当初在评估两个算法时间复杂度的时候精确到了常数时间操作，但是常数时间和常数时间用时可能不一样，比如加减乘除是常数时间操作，位运算也是常数时间操作，但明显位运算要快。
到了比拼两个算法常数时间操作的时候就不需要理论分析了，直接大样本测试进行比较。
7、时间复杂度排名
有小到大（由好到坏）：
O(1) < O(logN) < O(N) < O(N*logN) < O(N^K)k为常数且大于1 < O(K^N)k为常数且大于1 < O(N!)
8、假如用for循环遍历一次数组的时间复杂度是O(N)，我调用了有限且已知的M次这样的for循环，时间复杂度仍然是O(N)。这里要说的是M必须是和数据量无关的，也就是无论N是多少M都是已知的次数，那么M就是常数项，
估算时间复杂度的时候可以省略，还是O(N)；如果M是和数据量有关的，那么时间复杂度就是O(M * N)。
还有，假如一个for循环套一个for循环，这两个for循环一个是与数据量N有关，另一个循环已知常数次，那么整体的时间复杂度还是O(N)，因为循环已知常数次的哪个for循环的时间复杂度是O(1)。

二、空间复杂度
注意空间复杂度说的是额外空间复杂度，重点在”额外“二字。用户要求输入的不算额外空间，用户要求返回的不算额外空间，额外空间就是为了完成算法不得不开辟内存空间来完成功能。
它是描述额外开辟的内存空间和数据量N的关系。
对于”额外“的理解：
（1）比如用户给定一个数组，求这个数组的累加和。
算法的输入是用户给的数组，这个数组虽然占用内存空间，但是是用户给的已知条件，不是你为了完成算法而额外开辟的空间，所以输入的数组不能算做空间复杂度里面。
为了完成这个功能需要额外开辟一个变量，来保存所有元素的和，也就是我需要开辟已知的且有限的变量来完成功能，和数据量N无关，那么空间复杂度就是O(1)。
（2）比如用户给定一个数组，求这个数组出现频次最多的元素。
如果涉及一个map出来，key是元素值，value是频次，那么在最坏数据分布的情况下（原始数组所有元素都不一样），额外开辟的空间和数据量N事项等的，那么空间复杂度就是O(N)。
空间复杂度也是按最坏的情况估计。
（3）比如用户给定一个数组，让你生成一个新数组来拷贝这个数组的元素。
这时就需要开辟一个和原始数组长度一致的数组，然后进行拷贝，但是最终的空间复杂度是O(1)，原因是开辟出来的新数组虽然需要N个空间，但是这是题目要求的，题目要求的输入和输出都不是你为了完成功能而额外开辟的，
所以不能算在空间复杂度里面。

相比时间复杂度来说空间复杂度的的重要程度仅此之。

三、排序
1、排序算法：
（1）选择排序
（2）冒泡排序
（3）插入排序
（4）归并排序
（5）冒泡排序
（6）快速排序
（7）堆排序
（8）桶排序
	1）计数排序
		给定一个无序数组，每个元素的范围在[m,n]之间且m>=0且n不会太大，对该数组进行排序。
		思路：
		a）遍历一遍原数组arr，找出最大值maxValue
 		b）准备一个数组tmpArr，长度是maxValue + 1，这里的重点是tmpArr的索引值是arr的元素值，而tmpArr的元素值是arr某元素出现的次数
 		c）遍历tmpArr，根据每个元素出现的次数将所有元素平铺开来并逐个赋给arr
	2）基数排序
		给定一个无序数组，每个元素必须是非负的且能表达成十进制，对该数组进行排序。
		（其实负数也可以，要先找到最小的负数，然后所有元素都加上这个负数的相反数，将负数变为正数。但这里有一个隐患就是可能会超过数据类型的范围，一般情况下基数排序适用于非负数）
		思路：
		（有点难，暂略）
2、排序的算法的分类
（1）基于比较的排序
	排序算法的实现过程必须进行两两对比，这样的额排序算法有：除了桶排序之外的排序算法。基于比较的排序算法的时间复杂度都最好的是O(N*longN)。
	基于比较的排序适用范围是最广的，因为它没有什么特殊要求，只要是一个无序的数组就可以。
（2）不基于比较的排序
	桶排序，时间复杂度最好能达到O(N)。“不基于比较的排序”的适用范围要比“基于比较的排序”窄，不基于比较的排序都是在一定条件下的，除了给定一个无序数组之外，要么元素有要求要么数组长度有要求或者其他要求，
	所以不基于比较的排序一般适用在某些具有特殊特征的数组。
3、排序算法的稳定性
	排完序之后，相同元素的相对位置没有改变，比如数组[1,2,3,2,1]排完序后是[1,1,2,2,3]，排序前原数组的第一个元素是1，假如标识为1_1，最后一个元素也是1，假如标识为1_2，
	所以在原始数组中1_1排在1_2之前，排完序后，新数组的第一个元素的1如果是1_1，而第二个元素的2如果是1_2，那么排完序之后1_1还是在1_2前面， 相对位置没有变，这种排序算法就具有稳定性；
	相反如果排完序之后1_1跑到了1_2之后，就说这个排序算法不具有稳定性。
	当然对于基本数据类型来说具不具有稳定性没什么影响，如果数组的元素是复合类型那么就有可能有影响。比如元素是Student类的对象，Student类有两个属性：一个是年龄，一个是班级。
	如果先按照年龄排序得到一个新数组result1，再以result1为基础按照班级进行排序得到result2，如果排序算法是稳定的，那么在result2中，相同班级的学生年龄肯定是已经排好序的了；
	如果排序算法不是稳定的，那么相同班级的学生年龄的顺序不一定。
	那么哪些排序算法具有稳定性呢？
	具有稳定性的排序算法：冒泡排序、插入排序、归并排序
	不具有稳定性的排序算法：选择排序、快速排序、堆排序
4、各种排序算法的综合比较
