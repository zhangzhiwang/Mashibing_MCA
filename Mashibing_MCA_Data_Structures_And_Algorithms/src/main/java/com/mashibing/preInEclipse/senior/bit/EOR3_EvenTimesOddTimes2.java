package com.mashibing.preInEclipse.senior.bit;

/**
 * 异或题3——给定一个数组，有且只有两种元素会出现奇数次，其它都为偶数次，找出这两种数。（异或题2的升级版）
 * 思路：
 * 1、假设要求的这两种数是a和b，那么eor异或完所有元素之后得到eor = a ^ b。
 * 2、找到eor的二进制表示的最后一个1的位置，得到一个数tmp，不妨设第三位为1。
 * 3、申请另一个变量eor2，重新遍历数组的所有元素，让eor2和第三位为1的数进行^运算，可以得到a和b其中的一个值
 * 4、eor ^ eor2得到另一个值
 * 
 * @author zhangzhiwang
 * @date 2022年2月14日 下午2:45:46
 */
public class EOR3_EvenTimesOddTimes2 {
	public static void main(String[] args) {
		int[] arr = { 2, 2, 3, 3, 3, 3, 2, 1, 1, 1, 1, 1, 1, 9, 8, 9, 8, 9, 8, 9, 8, 9 };
		findOddTimes2(arr);
	}

	private static void findOddTimes2(int[] arr) {
		if (arr == null) {
			throw new RuntimeException("数组不能为空！");
		}

		/**
		 * 通过上一题（异或题2，EOR2_EvenTimesOddTimes.java）我们得出结论：当数组只有一个元素出现奇数次的时候，eor异或完arr的所有元素后得到的一定是那个出现了奇数次的元素a。
		 * 1、对于本题来说，eor异或完arr的所有元素后得到的一定是a ^ b，a、b都是出现了奇数次的元素也是最终要找出来的那两个数，所以异或完所有元素之后eor = a ^ b。
		 * 得出eor = a ^ b的依据是根据异或的交换律所有出现了偶数次的元素异或完是0，所有出现了奇数次的元素：每出现两次异或的结果是0，最后肯定有元素是落单的，那么0 ^ a = a，
		 * 由于题目给出了有两种数出现奇数次，所以肯定还会出现0 ^ b = b，所以eor = a ^ b。
		 * 2、由于题目中说是两种数，所以a!=b，所以eor = a ^ b != 0，所以eor的二进制表示中至少有一位是1的。
		 * （注意：异或运算的法则是”异为1“，这里说的两个操作数都是只有一位的二进制数，所以异或的结果不是0就是1，但是上面的a和b都是由若干个二进制位组成的，a ^ b != 0不能说明a ^ b的结果就是1，可以是除0外的任意数。）
		 * 我们不妨找出eor中最右边的1在哪里，这里就是前面的与题1，senior.bit.AND1.java，算法是：int tmp = eor & (-eor)，这里假设tmp的第三位是1，即：0000 1000。
		 * eor的第三位是1说明什么？因为eor是由a ^ b得来的，说明a和b的第三位有一个是1另一个是0。
		 * 3、根据上面第2步的结论：由于二进制数除了0就是1，所以可以把arr的所有元素分为两大阵营：一个是第三位为0的，一个是第三位不为0的，按照这个规则arr被分成了两拨，
		 * 那么a和b肯定被分到这两拨里面了，而且其中一拨有a，其中一拨有b，不妨设a的第三位是1，所以a被分到了第三位是1的那拨。
		 * 4、根据上面第3步的结论继续往下想：既然a被分到了第三位是1的那拨，那么再申请一个变量叫eor2，然后同样从头到尾遍历一遍arr数组，和第一次遍历数组不一样的是，
		 * eor2不是和所有的元素进行异或，而是只和第三位为1的元素进行异或运算。就像异或题2（EOR2_EvenTimesOddTimes.java）一样，第三位为1的数出现奇数次的一定就只有一个a，因为b被分到了另一拨。
		 * 第三位为1的出现偶数次的数和eor2异或完是0，所以遍历一遍arr数组之后eor2肯定能把a拽出来。
		 * 5、现在a有了，就是eor2，a ^ b也有了，就是eor，现在把b拽出来就行了，怎么得到b呢？eor ^ eor2就是b，a ^ b ^ a = b。
		 */
		int eor = 0;
		for (int i = 0; i < arr.length; i++) {
			eor ^= arr[i];
		}
		// 到此为止eor拽出来的是a ^ b，所以此时eor = a ^ b。
		// 由于a!=b，所以eor!=0，说明eor肯定有一个位上是1，我们找出任意一个1即可，所以我们不妨找eor的二进制中的最后一个1，这就是与题1（senior.bit.AND1.java）。这里假设第三位是1，即0000 1000
		int tmp = eor & (-eor);// 0000 1000

		// 再申请一个变量eor2，让它与arr中第三位（当然这里说的第三位是为了方便描述，假设tmp的第三位是1）是1的数进行^操作
		int eor2 = 0;
		for (int i = 0; i < arr.length; i++) {
			/**
			 * 如何判断一个数的第三位是不是1呢？因为tmp的第三位是1，其它所有位上都是0，所以让一个数与tmp进行&操作的结果是不是0就可以知道这个数的第三位是不是1了。
			 * 因为任何数与0&会得到0，任何数与1&如果结果是0那么说明这个数是0，否则是1。
			 */
			if ((tmp & arr[i]) != 0) {
				eor2 ^= arr[i];
			}
		}
		/**
		 * 第二次循环结束可以把a和b的其中之一拽出来，假设拽出来的是a，不妨设eor2 = a。
		 * 此时eor2 = a，eor = a ^ b，那么b = eor ^ eor2
		 */
		int another = eor ^ eor2;
		System.out.println(String.format("出现奇数次的为：%d和%d", eor2, another));

		/*
		注意：整个过程遍历了两次数组，时间复杂度按理来说应该是O(2*N)，由于时间复杂度要忽略常数项，所以整个过程的时间复杂度是O(N)。
		是要不是嵌套循环，是一次循环出来之后再进行一次循环，一共进行k次循环，像这种时间复杂度理应为O(k*N)，但是由于忽略常数项，所以最终的时间复杂度是O(N)。
		即使是嵌套循环，还要看每一层循环是否跟数据量N有关，如果都有关那么时间复杂度最后就是O(N^k)（假设有k层嵌套循环），如果某一层的循环和数据量无关，是一个固定次数的循环，
		那么这一层循环的时间复杂度就是O(1)，那么整体的时间复杂度就是O(N^(k-1))。比如：一共有三层嵌套循环，其中第二层循环是一个固定次数的循环，比如循环32次，无论数据量N是什么样的都循环32次，
		而第一层和第三层循环是和数据量N有关的，那么整体的时间复杂度就会使O(N^2)。
		 */
	}
}
